

syntax = "proto3";

package report;

// placeholders
message Interval {
  string start_time = 1;
  string end_time = 2;
}

// The below assumes a set of defaults for each deployment's
// event templates.
// To support this each event template will need to be tagged with
// the following:
// 1. whether it is a media type event template and if so what the
// media type is (e.g. video, display, etc.)
// 2. whether it represents a common set of event templates that
// span media types.
// 3. the deployment/market it is associated with

// Upon receiving a group of reporting sets, the API will be able to
// infer what event templates are involved and use that information
// to find the event tempalte definitions and apply defaults as needed.
// This is how the market measurement policy will be enforced.

// A set of defaults for the API will be specified such that default
// impression filters and other things can be determined. This mechanism
// will also enforce those aspects of the report that must exist.
// For example the Origin measurement policy requires MRC and AMI
// for Video in all reports.
// Details on the full set of defaults and the mechanisms for
// handling this are TBD.

// A Basic Report is composed of the following:
// At the top level the following are specified:
// 1. the report name
// 2. the reporting start and end times
// 3. media type specific filtering criteria (e.g. ami, mrc, custom).
//    defaults will exist for these and the measurement policy will be
//    enforced with respect to what may/must be reported on
// 4. a set of "page definitions" that specify which metrics to compute
// for which combination of reporting sets
// 5. a set of pages, one for each definition, that contain the results
//
// *** A note on the use of ReportingSets:
// The API will only work with primitive Reporting Sets or
// composite Reporting Sets that are composed only of unions and whose
// constituent Reporting Sets have no filters.
// Additionally all Event Groups in the reporting set must conform to a
// single media type, and no Event Group may appear in more than a single
// Reporting Set.
// Reporting Set names and display names will be echoed in the Results.
//
// An overall philosophy of this API is that the results should stand alone.
// That is, neither the report definition nor other API calls are required
// to be able to interpret the results.
message BasicReport {
  // Definition of the set of media types.
  // This will be moved to a common location.
  // Values will be added as new media types arise
  // and any particular market need only support a subset
  // of media types.
  enum MediaType {
    MEDIA_TYPE_UNSPECIFIED = 0;
    CROSS_MEDIA = 1;
    VIDEO = 2;
    DISPLAY = 3;
    OTHER = 4;
  }

  // The human readable title of the report.
  string title = 1;

  // The window time over which the report is run.
  Interval report_time = 2;

  // Specification of for custom viewability and completion filter.
  message CustomImpressionQualificationFilter {
    // Specification for a quantile
    enum Quantile {
      QUANTILE_UNSPECIFIED = 0;
      ZERO = 1;
      TWENTY_FIVE = 2;
      FIFTY = 3;
      SEVENTY_FIVE = 4;
      ONE_HUNDRED = 5;
    }

    // Specify a percent as a fraction or as a quantile
    message Percent {
      oneof value {
        float fraction = 1;
        Quantile quantile = 2;
      }
    }
    Percent viewability = 1;
    Percent completion = 2;
  }

  // Used to filter impressions by viewability and percent completion.
  // If particular filter values are not applicable to the media they
  // are applied to, the filters are ignored. (e.g. display cannot
  // be filtered by percent completion)
  message ImpressionQualificationFilter {
    // The media type the filter applies to.
    MediaType media_type = 1;

    // Request that impressions be filtered by a configured
    // filter type (e.g. AMI, MRC)
    // The valid values and their configurations are specified as
    // part of the market configuration.
    repeated string filter_names = 2;

    // A user defined filter.
    CustomImpressionQualificationFilter custom = 3;
  }

  // The set of filters for this report. There is at most
  // one filter per Media Type. Moreover, if any Reporting Set
  // used in this Report is associated with any particular Media Type
  // there must be a filter for that Media Type in this list.
  // A filter for MediaType = CROSS_MEDIA must be present if
  // any Pages are defined that contain Reporting Sets of
  // heterogeneous Media Type.
  //
  // These filters are applied
  // automatically based upon the Reporting Sets present in
  // the PageDefinition selector. For example if all Reporting
  // Sets in a page definition selector conform to the "video" media
  // type then the "video" filter is applied. On the other hand
  // if the media type is heterogenous then the cross-media
  // filter is applied.
  repeated ImpressionQualificationFilter qualification_filters = 3;

  // Specifies how to Group output metrics.
  message Grouping {
    // The name of a report template field to group by.
    // Only those event template fields that are tagged as groupable
    // and in the common template are supported.
    // Moreover, they must be enums (e.g. age bucket).
    // This could be extended in the future to support non-enums and
    // other grouping use cases..
    repeated string dimension_name = 1;
  }

  // The set of additional filters to be applied to the page of results.
  // Only those event templates that are specified in the "common" event
  // template may be provided as filters. (e.g. age bucket)
  message Filter {
    message Term {
      // The name of event template (aka dimension) to filter on
      string dimension_name = 1;
      // The value of the event template to filter
      string value = 2;
      // Whether the filter should be negated. This will not be
      // supported initially.
      // bool negate = 3;
    }
    // To begin with this will be a single term, but may be extended
    // to a disjunction of terms in the future.
    Term term = 1;
  }

  // Specify an anchoring order for incremental reach reports.
  // For example if the order is "rs1, rs2, rs3" then the following
  // are reported:
  // 1. The reach of rs1
  // 2. The reach of (rs1+rs2) - rs1 (i.e. the unique contribution of rs2)
  // 3. The reach of (rs1+rs2+rs3) - (rs1+rs2) (i.e. the unique contribution
  //    of rs3 with respect to rs1 and rs2.
  message AnchoredReachSpec {
    repeated string reporting_sets = 1;
  }

  // Indicates that the incremental reach between the incremental reporing
  // sets with respect to the baseline reporting sets should be computed.
  // For example if baseline = (rs1, rs2) and incremental = (rs3) then
  // the reach of (rs1 + rs2 + rs3) - (rs1 + rs2) is computed.
  // Note that this is a general mechanism that could be used to compute
  // either anchored reach or unique reach, but there are other more
  // expressive ways to compute anchored reach (see above) and
  // unique reach (see below).
  message IncrementalReachSpec {
    repeated string baseline_reporting_sets = 1;
    repeated string incremental_reporting_sets = 2;
  }

  // Specifies the Frequency, Groupings, and Filters for calculating
  // a set of Metrics
  // NOTE: Instead of reuse at this level we could consider reusable definitions
  // for each of Frequency+cumulative, grouping, and filters.
  message CalculationSpec {
    // The frequency at which metrics are reported.
    enum Frequency {
      FREQUENCY_UNSPECIFIED = 0;
      // Report metrics daily from the report start time to the report end time
      DAILY = 1;
      // Report metrics weekly from the report start time to the report end time
      // The day of the week metrics are reported for is the same as that of
      // the report start time. If the end date is not the same day of the week
      // a partial week will be reported and the last value will conincide with
      // the last day of the report.
      WEEKLY = 2;
      // Report metrics across the entire span from report start to report end.
      TOTAL = 3;
    }
    // The frequency for this page of results.
    Frequency frequency = 1;

    // Whether the metrics should be cumulative. This option has no effect
    // when the frequency is TOTAL.
    bool cumulative = 2;

    // A future option to support unique reach across time periods.
    // TODO: This shoudl live in a message with cumulative
    // bool unique_reach_by_time_period = 4;

    Grouping grouping = 4;

    // A conjunction of filters
    repeated Filter filters = 5;
  }
  // A map of calculation specs that can be reused across
  // Page Definitions.
  map<string, CalculationSpec> calculation_spec_map = 4;

  // The definition for a page of results
  message PageDefinition {
    // The title of the page
    string title = 1;

    // Specifies the calculation spec to be used by this Page
    // Definition.
    string calculation_spec_key = 2;

    // If specified the total population for the specified groupings and
    // filters that are associated with calculation spec is reported.
    bool population_size = 3;

    // The set of Metrics to be computed
    message MetricSpec {
      // Understanding this is VERY important.
      //
      // The resoure names of the Reporting Sets to report on.
      //
      // If all Reporting Sets are associated with a single media type,
      // the impression qualification filter for that media type will be
      // applied. Otherwise, if multiple media types are represented the cross
      // media filter will be used.
      //
      // Recall that a single ImpressionQualificationFilter pertains to a
      // single Media Type and that this is at most of such filter per Basic
      // Report. Also recall that a single ImpressionQualificationFilter can
      // contain multiple filters to be applied to that Media Type (e.g.
      // AMI, MRC, Custom).
      //
      // The effect of this is that for each filter present in the
      /// Impression Qualification Filter for the detected Media Type
      // a distinct set of metrics is computed.
      //
      // For example if a reporting set named "RS" is specified and
      // its Media Type is video then the system will find the
      // Impression Qualification Filter (IQF) whose media_type is equal to
      // VIDEO. Further assume that the VIDEO IQF has filter_names = [ami, mrc]
      // and also specifies a custom filter. Then, in this case, a set of
      // Metrics is generated for the ami, mrc, and custom filter. The specific
      // types of metrics generated are defined by the MetricType structure
      // below.
      repeated string reporting_sets = 1;

      // The types of available metrics.
      message MetricType {
        // This is the union reach of all reporting sets.
        bool reach = 1;

        // This is the union percent reach of all reporting sets.
        bool percent_reach = 2;

        // This is the union k plus reach for all reporting sets up
        // to the frequency specified.
        int32 k_plus_reach = 3;

        // If specified percent k plus reach is computed. This
        // option requires that a positive value be given for k_plus_reach.
        bool percent_k_plus_reach = 4;

        // If set, this will cause the unique reach of each reporting set
        // in the reporting_set_entry_names to be computed with respect to
        // all other reporting sets. It is an error to specify this if only
        // a single reporting set is specified.
        // For example if reporting_sets=[RS1, RS2, RS3] the unique reach
        // of RS1, RS2, and RS3 are computed.
        bool unique_reach = 5;

        // If specified the average frequency is reported.
        bool average_frequency = 6;

        // If specified the impression count is reported.
        bool impressions = 7;

        // If specified grps are reported.
        bool grps = 8;
      }
      MetricType metric_type = 2;
    }

    // Specifies the anchored reach calculations to perform.
    // See the very long comment on MetricSpec about how filters
    // and reporting sets interact. That also applies here.
    message AnchoredReachSpecs {
      repeated AnchoredReachSpec specs = 1;
    }

    // Specifies the incremental reach calculations to perform.
    // See the very long comment on MetricSpec about how filters
    // and reporting sets interact. That also applies here.
    message IncrementalReachSpecs {
      repeated IncrementalReachSpec specs = 1;
    }

    // How to compute this page of results.
    oneof selector {
      // The specification of the Metrics to be computed.
      MetricSpec metric_spec = 7;
      AnchoredReachSpecs anchored_reach_specs = 8;
      IncrementalReachSpecs incremental_reach_specs = 9;
    }
  }

  // Specifies the pages to compute.
  repeated PageDefinition page_definitions = 5;

  // A page of results. This should be interpretable without any knowledge of
  // the definition above.
  message Page {
    // The name of the page. This is the same value as given for the
    // page definition.
    string title = 1;

    // The metadata associated with a particular result.
    message ResultMetadata {
      // The time interval over which the result is computed.
      Interval interval = 2;

      // The reporting sets for which the result was computed.
      repeated string reporting_sets = 3;
      // The reporting set disply names for which the result was computed.
      // These are ordered the same as reporting_sets.
      repeated string reporting_set_display_names = 4;

      // The media type associated with the Reporting Sets (e.g. video,
      // cross-media)
      MediaType media_type = 5;

      // The qualification filter used when computing the result.
      oneof qualification_filter {
        string qualification_filter_name = 6;
        CustomImpressionQualificationFilter custom_qualification_filter = 7;
      }

      // Specifies a dimension and value grouped by.
      message ResultGroup {
        string dimension_name = 1;
        string value = 2;
      }
      // The set of groupings used for this Result.
      repeated ResultGroup grouping = 8;
      // The set of filters used for this result.
      repeated Filter filters = 9;
    }

    // The value of a result.
    message ResultValue {
      // The size of the population for the filters/grouping specified
      int32 population_size = 9;

      // The result when the page selector is metric_type
      message MetricResult {
        int32 reach = 1;
        float percent_reach = 2;
        // Index is frequency - 1.
        repeated int32 k_plus_reach = 3;
        repeated float percent_k_plus_reach = 4;
        int32 unique_reach = 5;
        float average_frequency = 6;
        int32 impressions = 7;
        float grps = 8;
      }

      // The result for one AnchoredReach spec
      message AnchoredReachResult {
        // The specification of the anchored reach used for this calculation
        AnchoredReachSpec spec = 1;
        // This is in the same order as the reporting setsin the spec.
        repeated int64 reach = 2;
      }
      // The result when the anchored reach selector is specified.
      message AnchoredReachResults {
        // These are order the same as in the page definition.
        repeated AnchoredReachResults results = 1;
      }

      // The result for one IncrementalReach spec
      message IncrementalReachResult {
        // The specification of the incremental reach used for this calculation
        IncrementalReachSpec spec = 1;
        // The value of the incremental reach
        repeated int64 reach = 2;
      }
      // The result when the incremental reach selector is specified.
      message IncrementalReachResults {
        // These are order the same as in the page definition.
        repeated IncrementalReachResults results = 1;
      }

      // The reported result as specified by the Page Definition selector.
      oneof result {
        MetricResult metric_result = 1;
        AnchoredReachResults anchored_reach_results = 2;
        IncrementalReachResults incremental_reach_results = 3;
      }
    }

    // A single result and its metadata. This is essentialy a row of
    // results in a page of results.
    message Result {
      ResultMetadata metadata = 1;
      ResultValue value = 2;
    }
    // All of the results for a Page
    repeated Result results = 2;
  }
  // The results for all Page Definitions.
  repeated Page pages = 6;
}
